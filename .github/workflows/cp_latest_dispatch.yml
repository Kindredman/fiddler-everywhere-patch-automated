name: Latest MAC NEWW
on:
  workflow_dispatch:
    inputs:
      os-and-arch:
        description: 'Operating System And Architecture'
        required: true
        default: 'Windows (x86_64)'
        type: choice
        options:
          - Windows (x86_64)
          - Linux (x86_64)
          - Mac (x86_64)
          - Mac (arm64)
      patch-server-port:
        description: 'Patch server port'
        required: true
        default: '5678'
      patch-user-email:
        description: 'Fake registered email'
        required: true
        default: 'long@telerik.com'
      patch-user-firstName:
        description: 'Fake registered first name'
        required: true
        default: 'Long'
      patch-user-lastName:
        description: 'Fake registered last name'
        required: true
        default: 'Wang'
      patch-user-country-code:
        description: 'Fake registered country code'
        required: true
        default: '86'
      patch-user-provider:
        description: 'Fake registered provider'
        required: true
        default: 'Google'

defaults:
  run:
    shell: pwsh

env:
  OS_ARCH: ${{ github.event.inputs.os-and-arch }}
  PATCH_SERVER_PORT: ${{ github.event.inputs.patch-server-port }}
  PATCH_USER_EMAIL: ${{ github.event.inputs.patch-user-email }}
  PATCH_USER_FNAME: ${{ github.event.inputs.patch-user-firstName }}
  PATCH_USER_LNAME: ${{ github.event.inputs.patch-user-lastName }}
  PATCH_USER_COUNTRYCODE: ${{ github.event.inputs.patch-user-country-code }}
  PATCH_USER_PROVIDER: ${{ github.event.inputs.patch-user-provider }}

jobs:
  init_os_arch:
    runs-on: ubuntu-latest
    outputs:
      library_extension: ${{ steps.set_library_extension.outputs.library_extension }}
      arch_code: ${{ steps.set_arch.outputs.arch_code }}

    steps:
      - name: Set Library Extension
        id: set_library_extension
        run: |
          $extension = 'not-selected'
          if ($env:OS_ARCH -eq 'Windows (x86_64)') { $extension = 'dll' }
          elseif ($env:OS_ARCH -eq 'Linux (x86_64)') { $extension = 'so' }
          elseif ($env:OS_ARCH -match 'Mac') { $extension = 'dylib' }
          else { throw "Unsupported OS: $env:OS_ARCH" }
          "library_extension=$extension" | Out-File -Append -FilePath $env:GITHUB_OUTPUT

      - name: Set Arch Code
        id: set_arch
        run: |
          $arch = 'not-selected'
          if ($env:OS_ARCH -eq 'Windows (x86_64)') { $arch = 'win32-x86_64' }
          elseif ($env:OS_ARCH -eq 'Linux (x86_64)') { $arch = 'linux-x86_64' }
          elseif ($env:OS_ARCH -eq 'Mac (arm64)') { $arch = 'mac-arm64' }
          elseif ($env:OS_ARCH -eq 'Mac (x86_64)') { $arch = 'mac-x86_64' }
          else { throw "Unsupported OS: $env:OS_ARCH" }
          "arch_code=$arch" | Out-File -Append -FilePath $env:GITHUB_OUTPUT

  scrape_fe_version:
    runs-on: ubuntu-latest
    outputs:
      scraped_version: ${{ steps.get_version.outputs.scraped_version }}
    steps:
      - uses: actions/checkout@v4
      - name: Run Scraper
        id: get_version
        working-directory: utils/fe-version-scraper
        run: ./GetLatest-FEVersion.ps1

  download-Yui-patch:
    runs-on: ubuntu-latest
    needs: [scrape_fe_version, init_os_arch]
    env: 
      SCRAPED_VERSION: ${{ needs.scrape_fe_version.outputs.scraped_version }}
      LIBRARY_EXTENSION: ${{ needs.init_os_arch.outputs.library_extension }}
      ARCH_CODE: ${{ needs.init_os_arch.outputs.arch_code }}
    outputs:
      Yui-fiddler-name: ${{ steps.Yui-fiddler-name.outputs.Yui-fiddler-name }}
    steps:
      - name: Compatibility Check
        run: |
          $ver = $env:SCRAPED_VERSION; $min = "5.17.0"
          if ($ver -and [version]$ver -ge [version]$min) { 
             echo "IS_COMPATIBLE_CONT=true" | Out-File -Append -FilePath $env:GITHUB_ENV
          } else { 
             echo "IS_COMPATIBLE_CONT=false" | Out-File -Append -FilePath $env:GITHUB_ENV
          }

      - name: Determine Filenames
        run: |
          if ($env:IS_COMPATIBLE_CONT -eq 'true') {
            echo "Yui_FIDDLER_NAME=fiddler.$env:LIBRARY_EXTENSION" >> $env:GITHUB_ENV
            echo "Yui_FIDDLER_NAME_NO_EXTENSION=fiddler" >> $env:GITHUB_ENV
            echo "Yui_RELEASE=continuous" >> $env:GITHUB_ENV
          } else {
            echo "Yui_FIDDLER_NAME=libfiddler.$env:LIBRARY_EXTENSION" >> $env:GITHUB_ENV
            echo "Yui_FIDDLER_NAME_NO_EXTENSION=libfiddler" >> $env:GITHUB_ENV
            # Note: Older versions logic is not fully handled here, assuming continuous for now based on recent Fiddler versions
            echo "Yui_RELEASE=continuous" >> $env:GITHUB_ENV
          }
      
      - name: Set Output Name
        id: Yui-fiddler-name
        run: echo "Yui-fiddler-name=${{ env.Yui_FIDDLER_NAME }}" >> $env:GITHUB_OUTPUT

      - name: Download Patch
        run: |
          New-Item -ItemType Directory -Path "Yui"
          $url = "https://github.com/project-yui/Yui-patch/releases/download/$env:Yui_RELEASE/yui-$env:Yui_FIDDLER_NAME_NO_EXTENSION-$env:ARCH_CODE-$env:Yui_RELEASE.$env:LIBRARY_EXTENSION"
          Invoke-WebRequest -Uri $url -OutFile "Yui\$env:Yui_FIDDLER_NAME"

      - uses: actions/upload-artifact@v4
        with:
          name: Yui-patch
          path: Yui/

  download-msojocs-server:
    runs-on: ubuntu-latest
    steps:
      - name: Sparse Checkout Server
        run: |
          git init
          git remote add origin https://github.com/msojocs/fiddler-everywhere-enhance.git
          git config core.sparseCheckout true
          Set-Content -Path ".git/info/sparse-checkout" -Value "server"
          git pull origin main
          New-Item -ItemType Directory -Path "msojocs" -Force
          Move-Item -Path "server" -Destination "msojocs/"
      - uses: actions/upload-artifact@v4
        with:
          name: msojocs-patch
          path: msojocs/

  download-fiddler-everywhere-windows:
    if: ${{ github.event.inputs.os-and-arch == 'Windows (x86_64)' }}
    runs-on: ubuntu-latest
    needs: [scrape_fe_version]
    steps:
      - name: Download & Extract
        run: |
          $ver = "${{ needs.scrape_fe_version.outputs.scraped_version }}"
          Invoke-WebRequest -Uri "https://downloads.getfiddler.com/win/Fiddler%20Everywhere%20$ver.exe" -OutFile "setup.exe"
          7z x "setup.exe" -ofe_extracted
          7z x "fe_extracted/`$PLUGINSDIR/app-64.7z" -ofe_app
      - uses: actions/upload-artifact@v4
        with:
          name: fe_app
          path: fe_app/

  download-fiddler-everywhere-linux:
    if: ${{ github.event.inputs.os-and-arch == 'Linux (x86_64)' }}
    runs-on: ubuntu-latest
    needs: [scrape_fe_version]
    steps:
      - name: Download & Extract
        run: |
          $ver = "${{ needs.scrape_fe_version.outputs.scraped_version }}"
          Invoke-WebRequest -Uri "https://downloads.getfiddler.com/linux/fiddler-everywhere-$ver.AppImage" -OutFile "setup.AppImage"
          chmod +x ./setup.AppImage
          ./setup.AppImage --appimage-extract
          mv squashfs-root fe_app
      - uses: actions/upload-artifact@v4
        with:
          name: fe_app
          path: fe_app/

  download-fiddler-everywhere-mac:
    if: contains(github.event.inputs.os-and-arch, 'Mac')
    runs-on: ubuntu-latest
    needs: [scrape_fe_version, init_os_arch]
    env:
      ARCH_CODE: ${{ needs.init_os_arch.outputs.arch_code }}
    steps:
      - name: Download & Extract (Linux Runner)
        run: |
          $ver = "${{ needs.scrape_fe_version.outputs.scraped_version }}"
          $arch = "${{ needs.init_os_arch.outputs.arch_code }}"
          
          $url = "https://downloads.getfiddler.com/mac/Fiddler%20Everywhere%20$ver.dmg"
          if ($arch -eq "mac-arm64") { $url = "https://downloads.getfiddler.com/mac-arm64/Fiddler%20Everywhere%20$ver.dmg" }
          
          Write-Host "Downloading $url"
          Invoke-WebRequest -Uri $url -OutFile "setup.dmg"
          
          # Use 7z to extract DMG on Linux
          7z x "setup.dmg" -ofe_extracted
          
          # 7z Extraction usually results in 'Fiddler Everywhere/Fiddler Everywhere.app/...'
          # We need to flatten this so 'fe_app' is the root of the .app
          New-Item -ItemType Directory -Path "fe_app"
          
          # Find the .app folder wherever it is
          $appDir = Get-ChildItem -Path fe_extracted -Recurse -Filter "*.app" | Select-Object -First 1
          if ($appDir) {
            Write-Host "Found App at $($appDir.FullName)"
            Copy-Item -Path "$($appDir.FullName)/*" -Destination "fe_app" -Recurse
          } else {
            Throw "Could not find .app folder inside DMG extraction"
          }
          
      - uses: actions/upload-artifact@v4
        with:
          name: fe_app
          path: fe_app/

patch_fe:
    runs-on: ubuntu-latest
    needs:
      - download-Yui-patch
      - download-msojocs-server
      - scrape_fe_version
      - download-fiddler-everywhere-windows
      - download-fiddler-everywhere-linux
      - download-fiddler-everywhere-mac
    if: always()
    env:
      SCRAPED_VERSION: ${{ needs.scrape_fe_version.outputs.scraped_version }}
      # We need the extension to know what to search for (dll, so, or dylib)
      LIBRARY_EXTENSION: ${{ needs.init_os_arch.outputs.library_extension }}
      # The patch file we downloaded
      YUI_DOWNLOADED_NAME: ${{ needs.download-Yui-patch.outputs.Yui-fiddler-name }}
    steps:
      - uses: actions/download-artifact@v4
        with: { name: Yui-patch, path: Yui-patch }
      - uses: actions/download-artifact@v4
        with: { name: msojocs-patch, path: msojocs-patch }
      - uses: actions/download-artifact@v4
        with: { name: fe_app, path: FE }

      - name: Determine JS App Root
        run: |
          # Mac apps have Contents/Resources/app/out
          # Win/Linux have resources/app/out
          if (Test-Path "FE/Contents/Resources/app/out") {
             echo "APP_ROOT=FE/Contents/Resources/app/out" >> $env:GITHUB_ENV
          } elseif (Test-Path "FE/resources/app/out") {
             echo "APP_ROOT=FE/resources/app/out" >> $env:GITHUB_ENV
          } else {
             Throw "Could not find app/out folder structure in FE artifact"
          }

      - name: Patch Binary (Fuzzy Search)
        run: |
          $ext = "$env:LIBRARY_EXTENSION"
          $patchSource = "Yui-patch/$env:YUI_DOWNLOADED_NAME"
          
          Write-Host "Searching for original binary matching '*fiddler.$ext'..."
          
          # Recursive search for any file matching *fiddler.dylib/dll/so (Case Insensitive)
          # This handles 'Fiddler.dylib', 'libfiddler.dylib', 'fiddler.dll', etc.
          $targetFiles = Get-ChildItem -Path "FE" -Recurse | Where-Object { $_.Name -match "fiddler\.$ext$" }
          
          if ($targetFiles) {
             # Pick the first match (usually there is only one core library)
             $targetFile = $targetFiles | Select-Object -First 1
             Write-Host "Found target binary at: $($targetFile.FullName)"
             
             # Copy the Yui patch to the target location, renaming it to match the original file
             Copy-Item -Path $patchSource -Destination $targetFile.FullName -Force
             Write-Host "Successfully replaced $($targetFile.Name) with Yui patch."
          } else {
             Write-Error "Could not locate any file resembling 'fiddler.$ext' inside the FE folder."
             exit 1
          }

      - name: Inject Server & Modify main.js
        run: |
          $appRoot = "$env:APP_ROOT"
          $serverSource = "msojocs-patch/server/file"
          $serverIndex = "msojocs-patch/server/index.js"
          
          # 1. Copy Server Files
          Copy-Item -Path $serverSource -Destination "$appRoot" -Recurse -Force
          
          # 2. Modify Port in index.js
          $idxContent = Get-Content $serverIndex -Raw
          $idxContent = $idxContent -replace 'const port = \d+;', "const port = $env:PATCH_SERVER_PORT;"
          
          # 3. Patch main.js (Shim)
          $mainJs = "$appRoot/main.js"
          if (Test-Path $mainJs) {
             $originalMain = Get-Content $mainJs -Raw
             Copy-Item $mainJs -Destination "$appRoot/main.original.js"
             # Combine Server Index + Original Main
             $newContent = $idxContent + "`n" + $originalMain
             Set-Content -Path $mainJs -Value $newContent
             Write-Host "Successfully injected server into main.js"
          } else {
             Throw "main.js not found at $mainJs"
          }

      - name: Set Fake User Identity
        run: |
          $tokenPath = "$env:APP_ROOT/file/identity.getfiddler.com/oauth/token.json"
          
          # Create directory if it doesn't exist (fresh install simulation)
          $parentDir = Split-Path -Parent $tokenPath
          if (-not (Test-Path $parentDir)) { New-Item -ItemType Directory -Path $parentDir -Force }
          
          if (Test-Path $tokenPath) {
             $json = Get-Content $tokenPath -Raw | ConvertFrom-Json
          } else {
             # Fallback simplified structure if file is missing
             $json = @{ user_info = @{ identities = @( @{} ) } } 
          }
          
          # Update Object
          $json.user_info | Add-Member -Force -MemberType NoteProperty -Name "email" -Value $env:PATCH_USER_EMAIL
          $json.user_info | Add-Member -Force -MemberType NoteProperty -Name "firstName" -Value $env:PATCH_USER_FNAME
          $json.user_info | Add-Member -Force -MemberType NoteProperty -Name "lastName" -Value $env:PATCH_USER_LNAME
          $json.user_info | Add-Member -Force -MemberType NoteProperty -Name "country" -Value $env:PATCH_USER_COUNTRYCODE
          $json.user_info.identities[0] | Add-Member -Force -MemberType NoteProperty -Name "providerName" -Value $env:PATCH_USER_PROVIDER
          
          $json | ConvertTo-Json -Depth 10 | Set-Content $tokenPath

      - name: Cleanup & Rename
        id: finalize
        run: |
          Remove-Item -Path "Yui-patch", "msojocs-patch" -Recurse -ErrorAction SilentlyContinue
          
          # Try to restore permissions (best effort for Linux/Mac)
          if ($IsLinux) {
             chmod -R +x FE
          }
          
          $finalName = "Fiddler-Everywhere-V$env:SCRAPED_VERSION-Patched"
          Rename-Item -Path "FE" -NewName $finalName
          echo "artifact_name=$finalName" >> $env:GITHUB_OUTPUT

      - uses: actions/upload-artifact@v4
        with:
          name: ${{ steps.finalize.outputs.artifact_name }}
          path: ${{ steps.finalize.outputs.artifact_name }}/
    runs-on: ubuntu-latest
    needs:
      - download-Yui-patch
      - download-msojocs-server
      - scrape_fe_version
      - download-fiddler-everywhere-windows
      - download-fiddler-everywhere-linux
      - download-fiddler-everywhere-mac
    if: always()
    env:
      SCRAPED_VERSION: ${{ needs.scrape_fe_version.outputs.scraped_version }}
      YUI_FIDDLER_NAME: ${{ needs.download-Yui-patch.outputs.Yui-fiddler-name }}
    steps:
      - uses: actions/download-artifact@v4
        with: { name: Yui-patch, path: Yui-patch }
      - uses: actions/download-artifact@v4
        with: { name: msojocs-patch, path: msojocs-patch }
      - uses: actions/download-artifact@v4
        with: { name: fe_app, path: FE }

      - name: Determine Paths (Mac vs Win/Linux)
        id: paths
        run: |
          # Mac apps have Contents/Resources/app/out
          # Win/Linux have resources/app/out
          if (Test-Path "FE/Contents/Resources/app/out") {
             echo "APP_ROOT=FE/Contents/Resources/app/out" >> $env:GITHUB_ENV
             echo "IS_MAC=true" >> $env:GITHUB_ENV
          } elseif (Test-Path "FE/resources/app/out") {
             echo "APP_ROOT=FE/resources/app/out" >> $env:GITHUB_ENV
             echo "IS_MAC=false" >> $env:GITHUB_ENV
          } else {
             Throw "Could not find app/out folder structure in FE artifact"
          }

      - name: Patch Binary (fiddler.dll/so/dylib)
        run: |
          # Find where the original binary is. It might be in APP_ROOT or parent folders.
          $yuiName = "$env:YUI_FIDDLER_NAME"
          $patchFile = "Yui-patch/$yuiName"
          
          # Search recursively in FE for the file to replace
          $targetFile = Get-ChildItem -Path "FE" -Recurse -Filter $yuiName | Select-Object -First 1
          
          if ($targetFile) {
             Copy-Item -Path $patchFile -Destination $targetFile.FullName -Force
             Write-Host "Patched binary at: $($targetFile.FullName)"
          } else {
             Write-Error "Could not locate original $yuiName inside FE folder."
          }

      - name: Inject Server & Modify main.js
        run: |
          $appRoot = "$env:APP_ROOT"
          $serverSource = "msojocs-patch/server/file"
          $serverIndex = "msojocs-patch/server/index.js"
          
          # 1. Copy Server Files
          Copy-Item -Path $serverSource -Destination "$appRoot" -Recurse -Force
          
          # 2. Modify Port in index.js
          $idxContent = Get-Content $serverIndex -Raw
          $idxContent = $idxContent -replace 'const port = \d+;', "const port = $env:PATCH_SERVER_PORT;"
          
          # 3. Patch main.js (Shim)
          $mainJs = "$appRoot/main.js"
          if (Test-Path $mainJs) {
             $originalMain = Get-Content $mainJs -Raw
             Copy-Item $mainJs -Destination "$appRoot/main.original.js"
             # Combine Server Index + Original Main
             $newContent = $idxContent + "`n" + $originalMain
             Set-Content -Path $mainJs -Value $newContent
             Write-Host "Successfully injected server into main.js"
          } else {
             Throw "main.js not found at $mainJs"
          }

      - name: Set Fake User Identity
        run: |
          $tokenPath = "$env:APP_ROOT/file/identity.getfiddler.com/oauth/token.json"
          
          # Create directory if it doesn't exist (fresh install simulation)
          $parentDir = Split-Path -Parent $tokenPath
          if (-not (Test-Path $parentDir)) { New-Item -ItemType Directory -Path $parentDir -Force }
          
          if (Test-Path $tokenPath) {
             $json = Get-Content $tokenPath -Raw | ConvertFrom-Json
          } else {
             # Fallback simplified structure if file is missing
             $json = @{ user_info = @{ identities = @( @{} ) } } 
          }
          
          # Update Object
          $json.user_info | Add-Member -Force -MemberType NoteProperty -Name "email" -Value $env:PATCH_USER_EMAIL
          $json.user_info | Add-Member -Force -MemberType NoteProperty -Name "firstName" -Value $env:PATCH_USER_FNAME
          $json.user_info | Add-Member -Force -MemberType NoteProperty -Name "lastName" -Value $env:PATCH_USER_LNAME
          $json.user_info | Add-Member -Force -MemberType NoteProperty -Name "country" -Value $env:PATCH_USER_COUNTRYCODE
          $json.user_info.identities[0] | Add-Member -Force -MemberType NoteProperty -Name "providerName" -Value $env:PATCH_USER_PROVIDER
          
          $json | ConvertTo-Json -Depth 10 | Set-Content $tokenPath

      - name: Cleanup & Rename
        id: finalize
        run: |
          Remove-Item -Path "Yui-patch", "msojocs-patch" -Recurse -ErrorAction SilentlyContinue
          
          # Try to restore permissions (best effort for Linux/Mac)
          if ($IsLinux) {
             chmod -R +x FE
          }
          
          $finalName = "Fiddler-Everywhere-V$env:SCRAPED_VERSION-Patched"
          Rename-Item -Path "FE" -NewName $finalName
          echo "artifact_name=$finalName" >> $env:GITHUB_OUTPUT

      - uses: actions/upload-artifact@v4
        with:
          name: ${{ steps.finalize.outputs.artifact_name }}
          path: ${{ steps.finalize.outputs.artifact_name }}/